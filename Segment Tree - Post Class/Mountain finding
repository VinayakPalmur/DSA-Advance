import java.io.*;
import java.util.*;
import java.awt.*;
import java.math.*;

class Main {
    public static void main(String[] args) throws Exception {
        new Solver().solve();
    }


    static class Solver {
        final Helper hp;
        final int MAXN = 1000_006;
        final long MOD = (long) 1e9 + 7;

        Solver() {
            hp = new Helper(MOD, MAXN);
            hp.initIO(System.in, System.out);
        }


        void solve() throws Exception {
            int i, j, k;
            FenwickTree[] seg;
            TreeMap<Integer, Long>[] pending = new TreeMap[]{new TreeMap<>(), new TreeMap<>()};
            long last;

            int N = hp.nextInt();
            if (N < 5) {
                System.out.println(0);
                return;
            }
            long[] A = hp.getLongArray(N);

            Integer[] idx = new Integer[N];
            for (i = 0; i < N; ++i) idx[i] = i;
            Arrays.sort(idx, (a, b) -> Long.compare(A[a], A[b]));

            long[][] prefix = new long[N][3];
            seg = new FenwickTree[]{new FenwickTree(N), new FenwickTree(N)};
            last = -7;

            for (int ind : idx) {
                if (A[ind] != last) {
                    while (!pending[0].isEmpty()) {
                        Map.Entry<Integer, Long> entry = pending[0].pollFirstEntry();
                        seg[0].update(entry.getKey(), entry.getValue());
                    }
                    while (!pending[1].isEmpty()) {
                        Map.Entry<Integer, Long> entry = pending[1].pollFirstEntry();
                        seg[1].update(entry.getKey(), entry.getValue());
                    }
                    last = A[ind];
                }

                ++prefix[ind][0];
                prefix[ind][1] = seg[0].query(0, ind - 1);
                prefix[ind][2] = seg[1].query(0, ind - 1);

                pending[0].put(ind, 1l);
                pending[1].put(ind, prefix[ind][1]);
            }
            pending[0].clear();
            pending[1].clear();

            long[][] suffix = new long[N][3];
            seg = new FenwickTree[]{new FenwickTree(N), new FenwickTree(N)};
            last = -7;

            for (int ind : idx) {
                if (A[ind] != last) {
                    while (!pending[0].isEmpty()) {
                        Map.Entry<Integer, Long> entry = pending[0].pollFirstEntry();
                        seg[0].update(entry.getKey(), entry.getValue());
                    }
                    while (!pending[1].isEmpty()) {
                        Map.Entry<Integer, Long> entry = pending[1].pollFirstEntry();
                        seg[1].update(entry.getKey(), entry.getValue());
                    }
                    last = A[ind];
                }

                ++suffix[ind][0];
                suffix[ind][1] = seg[0].query(ind + 1, N - 1);
                suffix[ind][2] = seg[1].query(ind + 1, N - 1);

                pending[0].put(ind, 1l);
                pending[1].put(ind, suffix[ind][1]);
            }
            pending[0].clear();
            pending[1].clear();

            long ans = 0;
            for (i = 0; i < N; ++i) {
                ans = (ans + prefix[i][2] * suffix[i][2] % MOD) % MOD;
            }
            hp.println(ans);

            hp.flush();
        }
    }


    static class FenwickTree {
        final long MOD = (long) 1e9 + 7;
        int N;
        long[] tree;

        FenwickTree(int size) {
            N = size + 1;
            tree = new long[N];
        }

        void update(int idx, long val) {
            ++idx;
            while (idx < N) {
                tree[idx] = (tree[idx] + val) % MOD;
                idx += idx & -idx;
            }
        }

        long query(int idx) {
            ++idx;
            long ret = 0;
            while (idx > 0) {
                ret = (ret + tree[idx]) % MOD;
                idx -= idx & -idx;
            }
            return ret;
        }

        long query(int l, int r) {
            long ret = query(r);
            if (l > 0) ret -= query(l - 1);
            return (ret % MOD + MOD) % MOD;
        }
    }


    static class Helper {
        final long MOD;
        final int MAXN;
        final Random rnd;

        public Helper(long mod, int maxn) {
            MOD = mod;
            MAXN = maxn;
            rnd = new Random();
        }


        public static int[] sieve;
        public static ArrayList<Integer> primes;

        public void setSieve() {
            primes = new ArrayList<>();
            sieve = new int[MAXN];
            int i, j;
            for (i = 2; i < MAXN; ++i)
                if (sieve[i] == 0) {
                    primes.add(i);
                    for (j = i; j < MAXN; j += i) {
                        sieve[j] = i;
                    }
                }
        }


        public static long[] factorial;

        public void setFactorial() {
            factorial = new long[MAXN];
            factorial[0] = 1;
            for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;
        }

        public long getFactorial(int n) {
            if (factorial == null) setFactorial();
            return factorial[n];
        }

        public long ncr(int n, int r) {
            if (r > n) return 0;
            if (factorial == null) setFactorial();
            long numerator = factorial[n];
            long denominator = factorial[r] * factorial[n - r] % MOD;
            return numerator * pow(denominator, MOD - 2, MOD) % MOD;
        }


        public long[] getLongArray(int size) throws Exception {
            long[] ar = new long[size];
            for (int i = 0; i < size; ++i) ar[i] = nextLong();
            return ar;
        }

        public int[] getIntArray(int size) throws Exception {
            int[] ar = new int[size];
            for (int i = 0; i < size; ++i) ar[i] = nextInt();
            return ar;
        }

        public String[] getStringArray(int size) throws Exception {
            String[] ar = new String[size];
            for (int i = 0; i < size; ++i) ar[i] = next();
            return ar;
        }

        public String joinElements(long[] ar) {
            StringBuilder sb = new StringBuilder();
            for (long itr : ar) sb.append(itr).append(" ");
            return sb.toString().trim();
        }


        public String joinElements(int[] ar) {
            StringBuilder sb = new StringBuilder();
            for (int itr : ar) sb.append(itr).append(" ");
            return sb.toString().trim();
        }

        public String joinElements(String[] ar) {
            StringBuilder sb = new StringBuilder();
            for (String itr : ar) sb.append(itr).append(" ");
            return sb.toString().trim();
        }

        public String joinElements(Object[] ar) {
            StringBuilder sb = new StringBuilder();
            for (Object itr : ar) sb.append(itr).append(" ");
            return sb.toString().trim();
        }


        public long gcd(long a, long b) {
            return b == 0 ? a : gcd(b, a % b);
        }

        public int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        }


        public long max(long[] ar) {
            long ret = ar[0];
            for (long itr : ar) ret = Math.max(ret, itr);
            return ret;
        }

        public int max(int[] ar) {
            int ret = ar[0];
            for (int itr : ar) ret = Math.max(ret, itr);
            return ret;
        }

        public long min(long[] ar) {
            long ret = ar[0];
            for (long itr : ar) ret = Math.min(ret, itr);
            return ret;
        }

        public int min(int[] ar) {
            int ret = ar[0];
            for (int itr : ar) ret = Math.min(ret, itr);
            return ret;
        }


        public long sum(long[] ar) {
            long sum = 0;
            for (long itr : ar) sum += itr;
            return sum;
        }

        public long sum(int[] ar) {
            long sum = 0;
            for (int itr : ar) sum += itr;
            return sum;
        }

        public void shuffle(int[] ar) {
            int r;
            for (int i = 0; i < ar.length; ++i) {
                r = rnd.nextInt(ar.length);
                if (r != i) {
                    ar[i] ^= ar[r];
                    ar[r] ^= ar[i];
                    ar[i] ^= ar[r];
                }
            }
        }

        public void shuffle(long[] ar) {
            int r;
            for (int i = 0; i < ar.length; ++i) {
                r = rnd.nextInt(ar.length);
                if (r != i) {
                    ar[i] ^= ar[r];
                    ar[r] ^= ar[i];
                    ar[i] ^= ar[r];
                }
            }
        }

        public long pow(long base, long exp, long MOD) {
            base %= MOD;
            long ret = 1;
            while (exp > 0) {
                if ((exp & 1) == 1) ret = ret * base % MOD;
                base = base * base % MOD;
                exp >>= 1;
            }
            return ret;
        }


        static byte[] buf = new byte[2048];
        static int index, total;
        static InputStream in;
        static BufferedWriter bw;


        public void initIO(InputStream is, OutputStream os) {
            try {
                in = is;
                bw = new BufferedWriter(new OutputStreamWriter(os));
            } catch (Exception e) {
            }
        }

        public void initIO(String inputFile, String outputFile) {
            try {
                in = new FileInputStream(inputFile);
                bw = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(outputFile)));
            } catch (Exception e) {
            }
        }

        private int scan() throws Exception {
            if (index >= total) {
                index = 0;
                total = in.read(buf);
                if (total <= 0)
                    return -1;
            }
            return buf[index++];
        }

        public String next() throws Exception {
            int c;
            for (c = scan(); c <= 32; c = scan()) ;
            StringBuilder sb = new StringBuilder();
            for (; c > 32; c = scan())
                sb.append((char) c);
            return sb.toString();
        }

        public int nextInt() throws Exception {
            int c, val = 0;
            for (c = scan(); c <= 32; c = scan()) ;
            boolean neg = c == '-';
            if (c == '-' || c == '+')
                c = scan();
            for (; c >= '0' && c <= '9'; c = scan())
                val = (val << 3) + (val << 1) + (c & 15);
            return neg ? -val : val;
        }

        public long nextLong() throws Exception {
            int c;
            long val = 0;
            for (c = scan(); c <= 32; c = scan()) ;
            boolean neg = c == '-';
            if (c == '-' || c == '+')
                c = scan();
            for (; c >= '0' && c <= '9'; c = scan())
                val = (val << 3) + (val << 1) + (c & 15);
            return neg ? -val : val;
        }

        public void print(Object a) throws Exception {
            bw.write(a.toString());
        }

        public void printsp(Object a) throws Exception {
            print(a);
            print(" ");
        }

        public void println() throws Exception {
            bw.write("\n");
        }

        public void println(Object a) throws Exception {
            print(a);
            println();
        }

        public void flush() throws Exception {
            bw.flush();
        }
    }
}
